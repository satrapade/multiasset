
\documentclass{article}


\usepackage[portrait, headheight = 0cm, margin=0.25cm, top = 0.25cm]{geometry} 
\usepackage[export]{adjustbox} 
\usepackage{graphicx}
\usepackage[dvipsnames,table]{xcolor} % [dvipsnames,table] for setting colors \usepackage{amsmath} \usepackage{xfrac}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
%\usetikzlibrary{external}
%\tikzexternalize % activate!
%\usepackage{sparklines}
\usepackage{xfrac}
\usepackage[space]{grffile}
\usepackage{hyperref}
\usepackage{listings}

\DeclareRobustCommand\Tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\DeclareRobustCommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\renewcommand{\familydefault}{\sfdefault}


\begin{document}


<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

source("https://raw.githubusercontent.com/satrapade/latex_utils/master/latex_helpers_v2.R")

source("https://raw.githubusercontent.com/satrapade/utility/master/utility_functions.R")
source("https://raw.githubusercontent.com/satrapade/utility/master/nn_cast.R")

temp_files<-list.files(
    path="figure",
    pattern="pdf$",
    recursive = FALSE,
    full.names = TRUE
)
file.remove(temp_files)

require(data.table)
require(scales)
require(RcppRoll)
require(magrittr)
require(fasttime)
require(lubridate)
require(scales)
require(fields)
require(gsubfn)
require(stringi)
require(Matrix)
require(akima)
require(ggplot2)

resampled_spx_vol<-"compressed_resampled_spx_vol.txt" %>% scan(character()) %>% decompress
resampled_sx5e_vol<-"compressed_resampled_sx5e_vol.txt" %>% scan(character()) %>% decompress
resampled_ftse_vol<-"compressed_resampled_ftse_vol.txt" %>% scan(character()) %>% decompress
resampled_nky_vol<-"compressed_resampled_nky_vol.txt" %>% scan(character()) %>% decompress
resampled_eem_vol<-"compressed_resampled_eem_vol.txt" %>% scan(character()) %>% decompress

all_vol<-rbind( # data.table with all volatilities
  data.table(resampled_spx_vol,market="spx"),
  data.table(resampled_sx5e_vol,market="sx5e"),
  data.table(resampled_ftse_vol,market="ftse"),
  data.table(resampled_nky_vol,market="nky"),
  data.table(resampled_eem_vol,market="eem")
)[,.(
    Date=as.Date(stri_sub(Date,1,10),format="%Y-%m-%d"),
    Strike=Strike,
    Days=Days,
    ImpliedVol=ImpliedVol,
    ClosePrice=ClosePrice,
    market=market
)][,
  .(
    Strike=Strike,
    Days=Days,
    ImpliedVol=ImpliedVol,
    ClosePrice=ClosePrice,
    market=market,
    market_count=length(market)
  ),
  keyby=Date
][ClosePrice>0]

# surface pillars
all_strikes<-all_vol[,.(strikes=sort(unique(Strike))),keyby=market]
all_maturities<-all_vol[,.(maturities=sort(unique(Days))),keyby=market]

listed_expiries_3m<-list(
    quote(month %in% c("March","June","September","December")),
    quote(wday=="Friday"),
    quote(wday_count==3)
)

listed_expiries_6m_a<-list(
    quote(month %in% c("June","December")),
    quote(wday=="Friday"),
    quote(wday_count==3)
)

listed_expiries_6m_b<-list(
    quote(month %in% c("March","September")),
    quote(wday=="Friday"),
    quote(wday_count==3)
)


#
# get common dates for all markets 
# in volsurface table
make_common_dates<-function(vsurfs){
  vsurfs[
    ,.(date=Date[1]),
    keyby=c("market","Date")
  ][
    ,.(markets=length(market)),keyby=date
  ][
    markets==max(markets),date
  ]
}


#
# make a shedule from a list of volatility surfaces
make_shedule<-function(volsurfs)
{
  common_dates<-make_common_dates(volsurfs)
  markets<-sort(unique(volsurfs$market))
  shedule_df <- data.table(
    date=rep(common_dates,times=length(markets)),
    market=rep(markets,each=length(common_dates))
  )
  shedule_df
}

# create a roll schedule from a shedule
make_roll_dates<-function(
  filter_list,
  vsurfs
){
  shedule<-make_shedule(vsurfs)
  date_df<-data.table(
    date=shedule$date,
    day=day(shedule$date),
    mday=mday(shedule$date),
    qday=qday(shedule$date),
    yday=yday(shedule$date),
    pday=seq_along(shedule$date),
    wday=weekdays(shedule$date),
    month=months(shedule$date),
    wday_count=ceiling(mday(shedule$date)/7)
  )[,.SD,keyby=date]
  
  roll_dates<-Reduce(
    function(a,b)eval(bquote(.(a)[.(b)])),
    filter_list,
    init=date_df
  )[,.SD,keyby=date][J(sort(unique(date))),.SD,mult="first"]
  
  roll_intervals<-data.table(
    start=c(min(shedule$date),roll_dates$date),
    end=c(roll_dates$date,max(shedule$date)),
    roll=c("pre",as.character(seq_along(1:(nrow(roll_dates)-1))),"post")
  )
  
  
  shedule_with_roll<-data.table(
    shedule,
    roll=roll_intervals$roll[findInterval(shedule$date,roll_intervals$start)]
  )[,.SD,keyby=roll]
  
  shedule_with_roll_and_intervals<-merge(
    x=shedule_with_roll,
    y=roll_intervals,
    by="roll"
  )[,.SD,keyby=date]
  
  
  px<-vsurfs[,.(
    date=as.Date(stri_sub(Date[1],1,10),format="%Y-%m-%d"),
    close=ClosePrice[1],
    vol=mean(ImpliedVol)
  ),keyby=c("market","Date"),][,.(date,market,close,vol)][,.SD,keyby=c("date","market")]
  
  shedule_with_price<-merge(
    x=shedule_with_roll_and_intervals,
    y=px,
    by=c("date","market")
  )
  
  shedule_with_price[,c(.SD,list(
    maturity=as.integer(end-date)
  ))]

}

#
# interpolate vols
# on resampled vol surface
#
interpolate_vol<-function(date,strike,days,vsurf)
{
  strikes<-sort(unique(vsurf$Strike))
  maturities<-sort(unique(vsurf$Days))
  option_dets<-data.table(
    date=date,
    lo_strike=strikes[findInterval(strike,strikes)],
    hi_strike=strikes[findInterval(strike,strikes)+1],
    lo_mat=maturities[findInterval(days,maturities)],
    hi_mat=maturities[findInterval(days,maturities)+1]
  )
  vol_ll<-merge(x=option_dets,y=vsurf,by.x=c("date","lo_strike","lo_mat"),by.y=c("Date","Strike","Days"))$ImpliedVol
  vol_lh<-merge(x=option_dets,y=vsurf,by.x=c("date","lo_strike","hi_mat"),by.y=c("Date","Strike","Days"))$ImpliedVol
  vol_hl<-merge(x=option_dets,y=vsurf,by.x=c("date","hi_strike","lo_mat"),by.y=c("Date","Strike","Days"))$ImpliedVol
  vol_hh<-merge(x=option_dets,y=vsurf,by.x=c("date","hi_strike","hi_mat"),by.y=c("Date","Strike","Days"))$ImpliedVol
  t_strike<-(strike-option_dets$lo_strike)/(option_dets$hi_strike-option_dets$lo_strike)
  t_mat<-(days-option_dets$lo_mat)/(option_dets$hi_mat-option_dets$lo_mat)
  rowSums(cbind(
    vol_ll*(1-t_strike)*(1-t_mat),
    vol_hl*(t_strike)*(1-t_mat),
    vol_lh*(1-t_strike)*(t_mat),
    vol_hh*(t_strike)*(t_mat)
  ))
}



# option models

# european call
EC <- function(S,X,t,r,v)
{
  ifelse(
    t<1e-10,
    pmax(S-X,0),
    local({
      d1 <- (log(S/X)+(r+0.5*v^2)*t)/(v*sqrt(t))
      d2 <- d1-v*sqrt(t)
      S*pnorm(d1)-X*exp(-r*t)*pnorm(d2)
    })
  )
}


# european put
EP  <- function(S,X,t,r,v)
{
  ifelse(
    t<1e-10,
    pmax(X-S,0),
    local({
      d1 <- (log(S/X)+(r+0.5*v^2)*t)/(v*sqrt(t))
      d2 <- d1-v*sqrt(t)
      X*exp(-r*t)*pnorm(-d2)-S*pnorm(-d1)
    })
  )
}


# strike solvers

# call premium to strike
C2K<-function(K,C,F,v,t,n=3){
  for(i in 1:n){
    d1<-(log(F/K)+(0.5*v^2)*t)/(v*sqrt(t))
    d2<-d1-v*sqrt(t)
    Nd1<-pnorm(d1)
    Nd2<-pnorm(d2)
    K<-F*Nd1/Nd2-C/Nd2
  }
  K
}

# put premium to strike
P2K<-function(K,P,F,v,t,n=3){
  for(i in 1:n){
    d1<-(log(F/K)+(0.5*v^2)*t)/(v*sqrt(t))
    d2<-d1-v*sqrt(t)
    Nmd1<-pnorm(-d1)
    Nmd2<-pnorm(-d2)
    K<-F*Nmd1/Nmd2+P/Nmd2
  }
  K
}

# delta to put strike 
D2CK<-function(delta,close,vol,maturity){
  close*exp(qnorm(1-delta,sd=vol*sqrt(maturity),lower.tail=TRUE))
}

# delta to call strike 
D2PK<-function(delta,close,vol,maturity){
  close*exp(qnorm(delta,sd=vol*sqrt(maturity),lower.tail=TRUE))
}



#
#
#
compute_option_premium<-function(
  shedule,
  all_vol,
  strike_fun=function(close,vol,maturity)close,
  model=EC,
  all_strikes=all_vol[,.(strikes=sort(unique(Strike))),keyby=market],
  all_maturities=all_vol[,.(maturities=sort(unique(Days))),keyby=market]
)merge(
  x=shedule[date==start,.(
    market,
    strike_close=close,
    strike_vol=vol,
    strike=strike_fun(close,vol,maturity),
    roll
  )],
  y=shedule[,.(date,market,close,roll,maturity)],
  by.x=c("market","roll"),
  by.y=c("market","roll")
)[,
  local({
    the_strikes<-all_strikes[market,strikes]
    the_maturities<-all_maturities[market,maturities]
    i<-findInterval(pmax(strike,0),the_strikes)
    j<-findInterval(pmax(maturity,0),the_maturities)
    dets<-data.table(
      date=date,
      market=market,
      lo_strike=the_strikes[i],
      hi_strike=the_strikes[i+1],
      lo_maturity=the_maturities[j],
      hi_maturity=the_maturities[j+1]
    )
    vol_ll<-merge(
      x=dets,
      y=all_vol,
      by.x=c("market","date","lo_strike","lo_maturity"),
      by.y=c("market","Date","Strike","Days")
    )$ImpliedVol
    vol_lh<-merge(
      x=dets,
      y=all_vol,
      by.x=c("market","date","lo_strike","hi_maturity"),
      by.y=c("market","Date","Strike","Days")
    )$ImpliedVol
    vol_hl<-merge(
      x=dets,
      y=all_vol,
      by.x=c("market","date","hi_strike","lo_maturity"),
      by.y=c("market","Date","Strike","Days")
    )$ImpliedVol
    vol_hh<-merge(
      x=dets,
      y=all_vol,
      by.x=c("market","date","hi_strike","hi_maturity"),
      by.y=c("market","Date","Strike","Days")
    )$ImpliedVol
    t_strike<-(strike-dets$lo_strike)/(dets$hi_strike-dets$lo_strike)
    t_mat<-(maturity-dets$lo_maturity)/(dets$hi_maturity-dets$lo_maturity)
    vol<-rowSums(cbind(
      vol_ll*(1-t_strike)*(1-t_mat),
      vol_hl*(t_strike)*(1-t_mat),
      vol_lh*(1-t_strike)*(t_mat),
      vol_hh*(t_strike)*(t_mat)
    ))
    premium<-ifelse(grepl("^[0-9]+$",roll),model(close, strike, maturity/365, 0,vol),0)
    list(
      date=date,
      strike_close=strike_close,
      strike_vol=strike_vol,
      strike=strike,
      option_maturity=maturity,
      option_vol=vol,
      premium=premium
    )
  }),
  keyby=market
]


#
#
#
make_backtest<-function(
  shedule,
  volsurf,
  model,
  strike_fun=function(close,vol,maturity)close*0.9
)
{
  
  # roll strikes, 
  # compute option premium
  options<-merge(
    x=shedule,
    y=compute_option_premium(
      shedule,
      volsurf,
      strike_fun=strike_fun,
      model=model
    )[,.(market,date,strike_close,strike,premium)],
    by.x=c("date","market"),
    by.y=c("date","market")
  )
  
  # 
  #
  backtest<-data.table(
    market=options$market,
    date=options$date,
    start=options$start,
    end=options$end,
    maturity=options$maturity,
    reval=options$premium/options$strike_close
  )[,c(.SD,list(
    consideration=ifelse(start==date,-reval,0),
    payout=ifelse(maturity==1,reval,0)
  ))][,c(.SD,list(
    cash=cumsum(consideration+payout),
    holdings=ifelse(maturity==1,0,reval)
  ))][,.(
    market,
    date,
    start,
    end,
    maturity,
    reval,
    consideration,
    payout,
    cash,
    holdings,
    pnl=cash+holdings
  )]

  #
  #
  backtest 
  
}

strategy_weights<-function(s)do.call(rbind,mapply(function(x)x$weight,s,SIMPLIFY=FALSE))

make_strategy<-function(
  strategy,
  shedule,
  volsurf
){
 
  bk<-mapply(function(leg){
    leg_res<-make_backtest(
      shedule=shedule,
      volsurf=volsurf,
      model=leg$model,
      strike_fun=leg$strike
    )
    leg_res
  },strategy,SIMPLIFY=FALSE)
  
  w<-strategy_weights(strategy)
  
  strat_res<-do.call(cbind,mapply(function(leg)leg$pnl,bk,SIMPLIFY=FALSE))%*%w
  
  data.table(
    date=bk[[1]]$date,
    pnl=strat_res[,1],
    roll=shedule[market==market[1],][,.SD,keyby=date][J(bk[[1]]$date),roll]
  )
  
}

#
# add stop-loss to strategy
#
stop_loss<-function(strategy,max_loss=(-0.05)){
  period_change<-c(TRUE,tail(strategy$roll,-1)!=head(strategy$roll,-1))
  squelched_seq_along<-seq_along(period_change)*period_change
  carry_fwd_seq_along<-cummax(squelched_seq_along)
  carry_fwd_pnl<-strategy$pnl[carry_fwd_seq_along]
  period_pnl<-strategy$pnl-carry_fwd_pnl
  below_stop<-period_pnl<max_loss
  cum_period_stop<-cumsum(below_stop)
  period_below_stop<-(cum_period_stop-cum_period_stop[carry_fwd_seq_along])>0
  pnl_diff<-c(strategy$pnl[1],diff(strategy$pnl))
  lagged_stop<-c(FALSE,period_below_stop[-1])
  stopped_pnl_diff<-pnl_diff*(!lagged_stop)
  stopped_pnl<-cumsum(stopped_pnl_diff)
  data.table(
    strategy,
    period=carry_fwd_seq_along,
    period_pnl=period_pnl,
    below_stop=below_stop,
    period_stop=period_below_stop,
    stopped_pnl=stopped_pnl
  )
}

# read DOF performance, 
# convert character to Date
# convert daily P&L to cummulative P&L
dof<- fread("dof.csv") %>% 
{setNames(.,tolower(names(.)))} %>%
{.$date<-as.Date(.$date,format="%Y-%m-%d"); .} %>%
{.$pnl<-cumsum(.$pnl); .}


shedule_3m<-make_roll_dates(
  filter_list=listed_expiries_3m,
  vsurfs=all_vol
)

shedule_6m_a<-make_roll_dates(
  filter_list=listed_expiries_6m_a,
  vsurfs=all_vol
)

shedule_6m_b<-make_roll_dates(
  filter_list=listed_expiries_6m_b,
  vsurfs=all_vol
)

@

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=
#
# strategies
#

########################################
# short 90-100 putspread
########################################
strategy_90_100_PS<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ close*0.9 },
    weight=(+1)
  ),
  leg2=list(
    model=EP,
    strike=function(close,vol,maturity){ close*1.0 },
    weight=(-1)
  )
)

########################################
# short ATM straddle
########################################
strategy_SS<-list(
  leg1=list(
    model=EC,
    strike=function(close,vol,maturity){ close*1.0 },
    weight=(-1)
  ),
  leg2=list(
    model=EP,
    strike=function(close,vol,maturity){ close*1.0 },
    weight=(-1)
  )
)

########################################
# CSC, 25-45 delta CS vs solve-P
########################################
strategy_CSC<-list(
  leg1=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      call_K_low<-K<-D2CK(0.45,close,vol,maturity/365)
      call_K_low
    },
    weight=(+1)
  ),
  leg2=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      call_K_hi<-K<-D2CK(0.25,close,vol,maturity/365)
      call_K_hi
    },
    weight=(-1)
  ),
  leg3=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      call_K_low<-K<-D2CK(0.45,close,vol,maturity/365)
      call_K_hi<-K<-D2CK(0.25,close,vol,maturity/365)
      CS_premium<-EC(close,call_K_low,maturity/365,0,vol)-EC(close,call_K_hi,maturity/365,0,vol)
      put_K<-P2K(close,CS_premium,close,vol,maturity/365)
      put_K
    },
    weight=(-1)
  )
)

########################################
# PSC, 25-45 delta PS vs solve-C
########################################
strategy_PSC<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K_hi<-D2PK(0.45,close,vol,maturity/365)
      put_K_hi
    },
    weight=(+1)
  ),
  leg2=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K_low<-D2PK(0.25,close,vol,maturity/365)
      put_K_low
    },
    weight=(-1)
  ),
  leg3=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      put_K_hi<-D2PK(0.45,close,vol,maturity/365)
      put_K_low<-D2PK(0.25,close,vol,maturity/365)
      PS_premium<-EP(close,put_K_hi,maturity/365,0,vol)-EP(close,put_K_low,maturity/365,0,vol)
      call_K<-C2K(close,PS_premium,close,vol,maturity/365)
      call_K
    },
    weight=(-1)
  )
)

########################################
# PR, 45 delta P vs solve-P @ half the
# premium at twice the size
########################################
strategy_PR<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K_hi<-D2PK(0.45,close,vol,maturity/365)
      put_K_hi
    },
    weight=(+1)
  ),
  leg2=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K_hi<-D2PK(0.45,close,vol,maturity/365)
      P_premium<-EP(close,put_K_hi,maturity/365,0,vol)
      put_K_low<-P2K(close,P_premium/2,close,vol,maturity/365)
      put_K_low
    },
    weight=(-2)
  )
)

########################################
# CR, 45 delta C vs solve-C @ half the
# premium at twice the size
########################################
strategy_CR<-list(
  leg1=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      call_K_low<-D2CK(0.45,close,vol,maturity/365)
      call_K_low
    },
    weight=(+1)
  ),
  leg2=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      call_K_low<-D2CK(0.45,close,vol,maturity/365)
      C_premium<-EC(close,call_K_low,maturity/365,0,vol)
      call_K_high<-C2K(close,C_premium/2,close,vol,maturity/365)
      call_K_high
    },
    weight=(-2)
  )
)

########################################
# ZCRR, 25 delta C vs solve-P 
########################################
strategy_ZCRR<-list(
  leg1=list(
    model=EC,
    strike=function(close,vol,maturity){ 
      call_K<-D2CK(0.25,close,vol,maturity/365)
      call_K
    },
    weight=(+1)
  ),
  leg2=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      call_K<-D2CK(0.25,close,vol,maturity/365)
      C_premium<-EC(close,call_K,maturity/365,0,vol)
      put_K<-P2K(close,C_premium,close,vol,maturity/365)
      put_K
    },
    weight=(-1)
  )
)

########################################
# TAIL2, 2 delta P
########################################
strategy_TAIL2<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K<-D2PK(0.02,close,vol,maturity/365)
      put_K
    },
    weight=(+1)
  )
)



#
# list of strategies
#
strategies<-list(
  SS=strategy_SS,
  CSC=strategy_CSC,
  PSC=strategy_PSC,
  CR=strategy_CR,
  PR=strategy_PR,
  ZCRR=strategy_ZCRR
)

strategies1<-list(
  SS=list(payoff=strategy_SS,shedule=shedule_3m),
  CSC=list(payoff=strategy_CSC,shedule=shedule_3m),
  PSC=list(payoff=strategy_PSC,shedule=shedule_3m),
  CR=list(payoff=strategy_CR,shedule=shedule_3m),
  PR=list(payoff=strategy_PR,shedule=shedule_3m),
  ZCRR=list(payoff=strategy_ZCRR,shedule=shedule_3m)
)


#
# list of markets
#
markets<-c(
  "spx",
  "sx5e",
  "ftse",
  "nky"
)


make_backtest_plot<-function(
  backtest,
  the_market,
  the_strategy,
  height="4cm",
  width="4cm"
)
{

  backtest_plot<- backtest %>% 
    ggplot() + 
    geom_line(aes(x=date,y=pnl),size=2,alpha=0.75)+ 
    ggtitle(paste0(toupper(the_market)," : ",the_strategy))+
    scale_x_date(breaks = pretty_breaks(10)) +
    theme(plot.title = element_text(size=28))
  
  plot_latex<-make_plot(
    plot(backtest_plot),
    height=height,
    width=width,
    envir=environment()
  )
  
  plot_latex
  
}

@


<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

x<-make_strategy(
  strategy=strategies[[1]],
  shedule=shedule_3m[market=="spx"],
  volsurf=all_vol[market=="spx"]
)





all_backtests_3m<-data.table(
  strategy=rep(names(strategies),times=length(markets)),
  market=rep(markets,each=length(strategies))
)[,c(.SD,list(
  backtest=mapply(function(the_market,the_strategy){
    make_strategy(
      strategy=strategies[[the_strategy]],
      shedule_3m[market==the_market],
      all_vol[market==the_market]
    )
  },market,strategy,SIMPLIFY=FALSE)
))][,c(.SD,list(
  plot=mapply(make_backtest_plot,backtest=backtest,the_market=market,the_strategy=strategy)
))]

all_backtests_6m_a<-data.table(
  strategy=rep(names(strategies),times=length(markets)),
  market=rep(markets,each=length(strategies))
)[,c(.SD,list(
  backtest=mapply(function(the_market,the_strategy){
    make_strategy(
      strategy=strategies[[the_strategy]],
      shedule_6m_a[market==the_market],
      all_vol[market==the_market]
    )
  },market,strategy,SIMPLIFY=FALSE)
))][,c(.SD,list(
  plot=mapply(make_backtest_plot,backtest=backtest,the_market=market,the_strategy=strategy)
))]

all_backtests_6m_b<-data.table(
  strategy=rep(names(strategies),times=length(markets)),
  market=rep(markets,each=length(strategies))
)[,c(.SD,list(
  backtest=mapply(function(the_market,the_strategy){
    make_strategy(
      strategy=strategies[[the_strategy]],
      shedule_6m_b[market==the_market],
      all_vol[market==the_market]
    )
  },market,strategy,SIMPLIFY=FALSE)
))][,c(.SD,list(
  plot=mapply(make_backtest_plot,backtest=backtest,the_market=market,the_strategy=strategy)
))]


NNcast<-function(
  data,
  i_name="date",
  j_name="id",
  v_name="value",
  fun=sum,
  scrub_fun=function(x)scrub(x,default=0),
  scrub=function(x, default = 0){
    if(length(x) == 0) return(default)
    x[which(!is.finite(x))] <- default
    return(x)
  }
){
  i_expr<-parse(text=as.character(i_name))
  j_expr<-parse(text=as.character(j_name))
  v_expr<-parse(text=as.character(v_name))
  i<-as.character(eval(i_expr,envir=data))
  j<-as.character(eval(j_expr,envir=data))
  x<-eval(v_expr,envir=data)
  df<-data.table(i=i,j=j,x=x)[,.(x=fun(x)),keyby="i,j"]
  is<-sort(unique(df$i))
  js<-sort(unique(df$j))
  res<-matrix(
    do.call(class(x),list(1)),
    nrow=length(is),
    ncol=length(js),
    dimnames = list(is,js)
  )
  i<-match(df$i,rownames(res))
  j<-match(df$j,colnames(res))
  res[cbind(i,j)[!is.na(df$x),]]<-df$x[!is.na(df$x)]
  scrub_fun(res)
}


backtest_3m_plot_matrix<-NNcast(
  all_backtests_3m,
  i_name="strategy",
  j_name="market",
  v_name="plot",
  fun=identity,
  scrub_fun = identity
)

backtest_6m_a_plot_matrix<-NNcast(
  all_backtests_6m_a,
  i_name="strategy",
  j_name="market",
  v_name="plot",
  fun=identity,
  scrub_fun = identity
)

backtest_6m_b_plot_matrix<-NNcast(
  all_backtests_6m_b,
  i_name="strategy",
  j_name="market",
  v_name="plot",
  fun=identity,
  scrub_fun = identity
)


@



\tableofcontents



<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

compute_drawdown_stats<-function(strategy){
  cum_max_px <- cummax(strategy$pnl)
  high_watermark <- (strategy$pnl==cum_max_px)
  squelched_seq_along<-seq_along(high_watermark)*high_watermark
  carry_fwd_seq_along<-cummax(squelched_seq_along)
  carry_fwd_pnl<-strategy$pnl[carry_fwd_seq_along]
  drawdown<-carry_fwd_pnl-strategy$pnl
  
  res<-data.table(
    strategy,
    drawdown=drawdown,
    high_watermark_value=carry_fwd_pnl,
    high_watermark_count=cumsum(high_watermark)
  )
  
  setkey(res,high_watermark_count)
  
  res_stats<-res[,list(
    max_draw=max(drawdown),
    length_draw=length(drawdown),
    date_draw=date[which.max(drawdown)]
  ),keyby=high_watermark_count]
  
  res_stats[res]
  
}

dof_drawdown_stats<-compute_drawdown_stats(dof)

g_dof <- dof %>% 
ggplot() +
geom_line(aes(x=date,y=pnl))

g_drawdown <- dof_drawdown_stats %>%
ggplot() +
geom_line(aes(x=date,y=drawdown))





@


\newpage
\section{DOF performance}

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\hline
\rowcolor{gray!20}
\multicolumn{1}{c}{\bf Performance}
&
\multicolumn{1}{c}{\bf Drawdown}
\\
\Sexpr{make_plot(plot(g_dof),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_drawdown),height="10cm",width="10cm")}
\\
\end{tabular}
\end{center}

\begin{itemize}
\item We wish to investigate the cause of infrequent, relatively large drawdowns.
\item In addition, we are looking for a simple, intuitive proxy that can be used to understand DOF performance.
\item Moreover, we investigate 3 different mitigation strategies: sizing, stop-loss and a positive tail-risk overlay.
\end{itemize}


\newpage
\section{Weighted strategy backtests}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

equal_backtest<-data.table(
  date=all_backtests_3m$backtest[[1]]$date,
  pnl=rowMeans(do.call(cbind,mapply(function(b)b$pnl,all_backtests_3m$backtest,SIMPLIFY=FALSE))),
  roll=all_backtests_3m$backtest[[1]]$roll
)

equal_backtest_drawdown_stats<-compute_drawdown_stats(equal_backtest)

g_equal<-melt(merge(
  x=equal_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)[,.(
  date,
  backtest=cumsum(c(0,diff(pnl.x)))*mean(diff(pnl.y))/mean(diff(pnl.x)),
  dof=cumsum(c(0,diff(pnl.y)))
)],id.vars = "date",measure.vars = c("backtest","dof")) %>% 
  ggplot() +
  geom_line(aes(x=date,y=value,col=variable),size=2,alpha=0.75)+
  ggtitle("Equal-weight all strategies, markets vs DOF")


g_equal_drawdown_stats <- rbind(
  data.table(dof_drawdown_stats[,.(date,drawdown)],strategy="dof"),
  data.table(equal_backtest_drawdown_stats[date %in% dof$date,.(date,drawdown)],strategy="equal")
) %>%
ggplot() +
geom_line(aes(x=date,y=drawdown,col=strategy),size=2,alpha=0.75)+
  ggtitle("Equal-weight all strategies, markets vs DOF drawdowns")

@
\subsection{equal weights}

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\Sexpr{make_plot(plot(g_equal),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_equal_drawdown_stats),height="10cm",width="10cm")}
\end{tabular}
\end{center}

\newpage
\subsection{theoretical weights  }

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

theoretical_weights<-c(
  CSC=0.33,
  PSC=0.0,
  ZCRR=0.0,
  PR=0.33,
  CR=0.0,
  SS=0.33
)

backtest_matrix<-local({
    res<-do.call(cbind,mapply(function(b)b$pnl,all_backtests_3m$backtest,SIMPLIFY=FALSE))
    colnames(res)<-paste0(all_backtests_3m$market,"|",all_backtests_3m$strategy)
    rownames(res)<-as.character(all_backtests_3m$backtest[[1]]$date,format="%Y-%m-%d")
    res
  })

theoretical_backtest<-data.table(
  date=all_backtests_3m$backtest[[1]]$date,
  pnl=local({
    drop(backtest_matrix %*% cbind(theoretical_weights[all_backtests_3m$strategy] %>% {./sum(.)}))
  }),
  roll=all_backtests_3m$backtest[[1]]$roll
)

theoretical_backtest_drawdown_stats<-compute_drawdown_stats(theoretical_backtest)

g_theoretical<-melt(merge(
  x=theoretical_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)[,.(
  date,
  backtest=cumsum(c(0,diff(pnl.x)))*mean(diff(pnl.y))/mean(diff(pnl.x)),
  dof=cumsum(c(0,diff(pnl.y)))
)],id.vars = "date",measure.vars = c("backtest","dof")) %>% 
  ggplot() +
  geom_line(aes(x=date,y=value,col=variable),size=2,alpha=0.75)+
  ggtitle("Theoretical-weight all strategies, markets vs DOF")

g_theoretical_drawdown_stats <- rbind(
  data.table(dof_drawdown_stats[,.(date,drawdown)],strategy="dof"),
  data.table(theoretical_backtest_drawdown_stats[date %in% dof$date,.(date,drawdown)],strategy="theoretical")
) %>%
ggplot() +
geom_line(aes(x=date,y=drawdown,col=strategy),size=2,alpha=0.75)+
  ggtitle("Theoretical-weight all strategies, markets vs DOF drawdowns")


@


\begin{center}
\begin{tabular}{l l}
\hline
\rowcolor{gray!20}
\multicolumn{2}{c}{Portfolio composition} \\
Zero Cost Call Spread Collars & 33 \% \\
Zero Cost Put Spread Collars & 0 \% \\
Zero Cost Risk Reversals & 0 \% \\
Zero Cost Put Spread Ratios & 33 \% \\
Short Straddles & 33 \% \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\Sexpr{make_plot(plot(g_theoretical),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_theoretical_drawdown_stats),height="10cm",width="10cm")}
\end{tabular}
\end{center}



\newpage
\subsection{historical weights}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

historical_weights<-c(
  CSC=0.43,
  PSC=0.19,
  ZCRR=0.07,
  PR=0.15,
  CR=0.0,
  SS=0.16
)

backtest_matrix<-local({
    res<-do.call(cbind,mapply(function(b)b$pnl,all_backtests_3m$backtest,SIMPLIFY=FALSE))
    colnames(res)<-paste0(all_backtests_3m$market,"|",all_backtests_3m$strategy)
    rownames(res)<-as.character(all_backtests_3m$backtest[[1]]$date,format="%Y-%m-%d")
    res
  })

historical_backtest<-data.table(
  date=all_backtests_3m$backtest[[1]]$date,
  pnl=local({
    drop(backtest_matrix %*% cbind(historical_weights[all_backtests_3m$strategy] %>% {./sum(.)}))
  }),
  roll=all_backtests_3m$backtest[[1]]$roll
)

historical_backtest_drawdown_stats<-compute_drawdown_stats(historical_backtest)

g_historical<-melt(merge(
  x=historical_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)[,.(
  date,
  backtest=cumsum(c(0,diff(pnl.x)))*mean(diff(pnl.y))/mean(diff(pnl.x)),
  dof=cumsum(c(0,diff(pnl.y)))
)],id.vars = "date",measure.vars = c("backtest","dof")) %>% 
  ggplot() +
  geom_line(aes(x=date,y=value,col=variable),size=2,alpha=0.75)+
  ggtitle("Historical-weight all strategies, markets vs DOF")

g_historical_drawdown_stats <- rbind(
  data.table(dof_drawdown_stats[,.(date,drawdown)],strategy="dof"),
  data.table(historical_backtest_drawdown_stats[date %in% dof$date,.(date,drawdown)],strategy="theoretical")
) %>%
ggplot() +
geom_line(aes(x=date,y=drawdown,col=strategy),size=2,alpha=0.75)+
  ggtitle("Historical-weight all strategies, markets vs DOF drawdowns")


@


\begin{center}
\begin{tabular}{l l}
\hline
\rowcolor{gray!20}
\multicolumn{2}{c}{Portfolio composition} \\
Zero Cost Call Spread Collars & 43 \% \\
Zero Cost Put Spread Collars & 19 \% \\
Zero Cost Risk Reversals & 7\% \\
Zero Cost Put Spread Ratios & 15 \% \\
Short Straddles & 16 \% \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\Sexpr{make_plot(plot(g_historical),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_historical_drawdown_stats),height="10cm",width="10cm")}
\end{tabular}
\end{center}



\newpage
\section{SPX Q90-100 PS vs DOF performance}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

spx_90_100_ps_backtest<-make_strategy(
  strategy=strategy_90_100_PS,
  shedule_3m[market=="spx"],
  all_vol[market=="spx"]
)

spx_90_100_ps_backtest_drawdown_stats<-compute_drawdown_stats(spx_90_100_ps_backtest)

g_spx_90_100_ps<-melt(merge(
  x=spx_90_100_ps_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)[,.(
  date,
  backtest=cumsum(c(0,diff(pnl.x)))*mean(diff(pnl.y))/mean(diff(pnl.x)),
  dof=cumsum(c(0,diff(pnl.y)))
)],id.vars = "date",measure.vars = c("backtest","dof")) %>% 
  ggplot() +
  geom_line(aes(x=date,y=value,col=variable),size=2,alpha=0.75)+
  ggtitle("Quarterly rolling short 100-90 pct SPX put spreads vs DOF")

g_spx_90_100_ps_drawdown_stats <- rbind(
  data.table(dof_drawdown_stats[,.(date,drawdown)],strategy="dof"),
  data.table(spx_90_100_ps_backtest_drawdown_stats[date %in% dof$date,.(date,drawdown)],strategy="theoretical")
) %>%
ggplot() +
geom_line(aes(x=date,y=drawdown,col=strategy),size=2,alpha=0.75)+
  ggtitle("spx_90_100_ps vs DOF drawdowns")

@

\noindent We examine a very simple strategy that seems to have similar drawdown performance with DOF. The
value of this proxy is that its behaviour is very intuitive and allows for easy judgement of scenario outcomes.

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\Sexpr{make_plot(plot(g_spx_90_100_ps),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_spx_90_100_ps_drawdown_stats),height="10cm",width="10cm")}
\end{tabular}
\end{center}


\newpage
\section{Drawdown mitigation: SPX ``teenies''}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

########################################
# TAIL1, 1 delta P
########################################
strategy_TAIL1<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K<-D2PK(0.01,close,vol,maturity/365)
      put_K
    },
    weight=(+1)
  )
)


########################################
# TAIL2, 2 delta P
########################################
strategy_TAIL2<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K<-D2PK(0.02,close,vol,maturity/365)
      put_K
    },
    weight=(+1)
  )
)

########################################
# TAIL5, 5 delta P
########################################
strategy_TAIL5<-list(
  leg1=list(
    model=EP,
    strike=function(close,vol,maturity){ 
      put_K<-D2PK(0.05,close,vol,maturity/365)
      put_K
    },
    weight=(+1)
  )
)



spx_tail1_backtest<-make_strategy(
  strategy=strategy_TAIL1,
  shedule_3m[market=="spx"],
  all_vol[market=="spx"]
)

spx_tail2_backtest<-make_strategy(
  strategy=strategy_TAIL2,
  shedule_3m[market=="spx"],
  all_vol[market=="spx"]
)

spx_tail5_backtest<-make_strategy(
  strategy=strategy_TAIL5,
  shedule_3m[market=="spx"],
  all_vol[market=="spx"]
)


x<-merge(
  x=spx_tail2_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)

g_tails<-rbind(
  data.table(spx_tail1_backtest,delta="1"),
  data.table(spx_tail2_backtest,delta="2"),
  data.table(spx_tail5_backtest,delta="5")
) %>% 
  ggplot() +
  geom_line(aes(x=date,y=pnl,col=delta),size=2,alpha=0.75)+
  ggtitle("Tail hedges: 1, 2 and 5 deltas")

g_tail2_vs_dof<-melt(merge(
  x=spx_tail2_backtest,
  y=dof,
  by.x="date",
  by.y="date"
)[,.(
  date,
  teeny=cumsum(c(0,diff(pnl.x))),
  dof=cumsum(c(0,diff(pnl.y)))
)],id.vars = "date",measure.vars = c("teeny","dof")) %>% 
  ggplot() +
  geom_line(aes(x=date,y=value,col=variable),size=2,alpha=0.75)+
  ggtitle("Quarterly rolling 2-delta SPX puts vs DOF")



@

\vskip 5mm

\noindent Downside mitigation can be achieved using ``teenies'', i.e. very low delta puts (50 to 300 bps).
These options almost never pay out anything at settlement. However, their value tends to spike during 
market-wide bouts of liquidation. We can take advantage of this by holding some amount of these and
selling them back whever their value spikes by a pre-determined amount. The combined portfolio should
have smaller returns but much reduced drawdowns. The key to this risk-mitigation strategy is that
we use a ``stop-profit'' on the tail-protection portfolio rather than a ``stop-loss'' on the risk-premium
portfolio. The reason this works better than stop-losses is that volatility risk premia are very strongly 
mean-reverting. It is better to buy tail-risk when the market is calm and then sell volatility on the pop 
rather than stop-out the risk premium collection portfolio on the pop and buy the volatility highs.
(tail risk becomes vol risk on a strong selloff, the teenies become 5-10 deltas pretty quickly)

\vskip 5mm

\begin{center}
\Sexpr{make_plot(plot(g_tail2_vs_dof),height="20cm",width="20cm")}
\end{center}

\newpage

\vskip 5mm

\noindent The key metric for choosing a tail hedge is the ratio of premium to potential upside. We
expect to rarely be able to recoup any of the premium, since tail options almost never end up paying
out anything. From this viewpoint, lower delta options are the best choice. For the examples examined 
in thise report, 1-delta SPX puts have the best ratio of premium to "price pop" during a selloff. 

\vskip 5mm


\begin{center}
\Sexpr{make_plot(plot(g_tails),height="20cm",width="20cm")}
\end{center}

\newpage
\section{All backtests}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

combined_backtest<-rbind(
  data.table(equal_backtest,weight="equal"),
  data.table(theoretical_backtest,weight="theoretical"),
  data.table(historical_backtest,weight="historical"),
  data.table(spx_90_100_ps_backtest,weight="spx90-100ps")
)
g_combined <- combined_backtest %>% 
  ggplot() +
  geom_line(aes(x=date,y=pnl,col=weight),size=2,alpha=0.75)+
  ggtitle("All backtests")

@


\begin{center}
\Sexpr{make_plot(plot(g_combined),height="20cm",width="20cm")}
\end{center}

\newpage
\section{Strategies vs market backtests}

\subsection{3m maturity}

\begin{center}
\Sexpr{matrix2tabular(backtest_3m_plot_matrix)}
\end{center}

\newpage
\subsection{6m (Jun, Dec) maturities}

\begin{center}
\Sexpr{matrix2tabular(backtest_6m_a_plot_matrix)}
\end{center}

\newpage
\subsection{6m (Mar, Sep) maturities}

\begin{center}
\Sexpr{matrix2tabular(backtest_6m_b_plot_matrix)}
\end{center}

\newpage
\section{Dataset}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=

g_close<-shedule_3m %>% 
  ggplot() +
  geom_line(aes(x=date,y=close,col=market)) +
  ggtitle("Market closing prices")

g_vol<-shedule_3m %>% 
  ggplot() +
  geom_line(aes(x=date,y=vol,col=market)) +
  ggtitle("Market average volatility")


@


We use historical volatility surfaces from JPM's OptionMetrics database. Average volatility,
closing prices by market shown below. 

\vskip 5mm

\begin{tabular}{m{10cm}m{10cm}}
\hline
\Sexpr{make_plot(plot(g_close),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_vol),height="10cm",width="10cm")}
\end{tabular}

\newpage
\section{Backtest algorithm}

<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=
@

\subsection{backtest inputs}

\noindent A backtest requires the following inputs:

\vskip 5mm

\begin{enumerate}
\item volatility surface
\item schedule
\item payoff
\end{enumerate}

\vskip 5mm

\subsection{volatility surface input}

\vskip 5mm

\noindent The volatility surface input is an R {\tt data.table} containing volatility
marks for all markets, strikes and maturities. The data is stored in ``long format'', 
so every volatility mark occupies a single row. The schema is as follows:

\vskip 5mm

\begin{center}
\begin{tabular}{l l}
\hline
\rowcolor{gray!20}
\multicolumn{2}{c}{ volatility surface} \\
{\tt Date} & reval date \\
{\tt Strike} & option strike \\
{\tt Days} & option maturity \\
{\tt ImpliedVol} & implied volatility \\
{\tt ClosePrice} & closing price underlying \\
{\tt market} & market name \\
\end{tabular}
\end{center}

\vskip 5mm

\subsection{shedule input}

\vskip 5mm


\noindent The schedule input is an R {\tt data.table} containing one row for each date
and market we want bactested p\&l for. In addition to these data items, the shedule contains
the market's close, the average volatility and the current roll period number, start date, 
end date and days left. Options are assumed to expire on the last day of their respective 
roll period.

\vskip 5mm

\begin{center}
\begin{tabular}{l l}
\hline
\rowcolor{gray!20}
\multicolumn{2}{c}{ shedule } \\
{\tt date} & trading date  \\
{\tt market} & market \\
{\tt close } & closing price \\
{\tt vol } & average vol across all strikes and maturities \\
{\tt roll } & roll period \\
{\tt start} & roll period starting date \\
{\tt end} & roll period end date \\
{\tt maturity} & days until end of current roll period \\
\end{tabular}
\end{center}

\vskip 5mm

\subsection{payoff input}

\vskip 5mm

\noindent the payoff is an R {\tt data.table} containing one row for each of the
payoffs we intend to roll on each roll date. For each payoff, the table 
contains a valuation model and a roll function. The valuation model is used
to compute option values on each day in the roll period. The roll function is
used to compute option strikes on roll dates. The valuation model is calld for
each day in the shedule. The roll function is called only on roll period start days

\vskip 5mm

\begin{center}
\begin{tabular}{l l}
\hline
\rowcolor{gray!20}
\multicolumn{2}{c}{ payoff } \\
model & {\tt function(spot,strike,maturity,rate,volatility)} \\
strike & {\tt function(spot,volatility)} \\
\end{tabular}
\end{center}

\newpage
\subsection{backtest workflow}

\vskip 5mm

\begin{itemize}
\item start with shedule
\item (not vectorized) compute table of strikes for each roll date (date is equal to start of roll period)
by calling roll function. Since roll dates are months appart, the roll function is called relatively
infrequently and does not need to be optimized. 
\item {\tt LEFT JOIN} option strikes on roll period. strikes are constant over the whole roll period. We use
the {\tt data.table} {\bf X[Y]} idiom to achieve this, it is very fast.
\item (vectorized) compuite maturity, strike pillars surrounding contract economics. We use the {\tt findInterval}
function for this, which is very fast.
\item {\tt LEFT JOIN} surface volatilities on surrounding pillars. {\tt data.table}'s {\bf X[Y]} idiom is used
here too.
\item (vectorized) perform biliear interpolation. This is done on the whole {\tt data.table} in one go since
the biliear interpolation formula is vectorizeable.
\item (vectorized) call valuation model, store reval. The model needs to support vectorized operation, there
is a single call with vectors of spot, vol, maturity, strike and rate as inputs.
\end{itemize}

\vskip 5mm

The calculations outlined are vectorizeable. This means that the backtest is quite fast. We can backtest
a single option on a single market over a 20-year period in about 0.5 seconds. 

\newpage
\subsection{volatility interpolation}

\vskip 5mm
The {\tt interpolate\_vol} function takes a reval date, a strike and a maturity as inputs
and performs volatility intepolation on a single-market volatility surface. This calculation
needs to be performed for every day, every market and every strike in the strategy. This means
that the number of interpolations can run into the hundreds of thousands .It is therefore
really important to be as efficient as possible. This means we need to vectorize operations
as much as we can. The calculation as shown works well for a single market. To do intepolation over 
multiple markets (for example from a multi-market shedule), we will use the {\tt data.table} 
{\bf keyby} feature to split the schedule by market and perform  the interpolation on every 
subset separately, inside the {\tt data.table}'s {\bf J} expression.

\lstset{
language=R,
numbers=left,
basicstyle=\footnotesize\ttfamily,
commentstyle=\itshape\color{purple!40!black},
}   

\begin{lstlisting}

interpolate_vol<-function(date,strike,days,vsurf)
{

  # vector of strike pillars in vol surface
  strikes<-sort(unique(vsurf$Strike))
  
  # vector of maturity pillars in vol surface
  maturities<-sort(unique(vsurf$Days))
  
  # volatility surface pillars surrounding contract 
  # strike and expiry days
  option_dets<-data.table(
    date=date,
    lo_strike=strikes[findInterval(strike,strikes)],
    hi_strike=strikes[findInterval(strike,strikes)+1],
    lo_mat=maturities[findInterval(days,maturities)],
    hi_mat=maturities[findInterval(days,maturities)+1]
  )
  
  # left join lower left corner's volatility
  vol_ll<-merge(
    x=option_dets,
    y=vsurf,
    by.x=c("date","lo_strike","lo_mat"),
    by.y=c("Date","Strike","Days")
  )$ImpliedVol
  
  # left join higher left corner's volatility
  vol_lh<-merge(
    x=option_dets,
    y=vsurf,
    by.x=c("date","lo_strike","hi_mat"),
    by.y=c("Date","Strike","Days")
  )$ImpliedVol
  
  # left join right lower corner's volatility
  vol_hl<-merge(
    x=option_dets,
    y=vsurf,
    by.x=c("date","hi_strike","lo_mat"),
    by.y=c("Date","Strike","Days")
  )$ImpliedVol
  
  # left join right higher corner's volatility
  vol_hh<-merge(
    x=option_dets,
    y=vsurf,
    by.x=c("date","hi_strike","hi_mat"),
    by.y=c("Date","Strike","Days")
  )$ImpliedVol
  
  # coordinates of contract strike, expiry inside surrounding pillar points
  t_strike<-(strike-option_dets$lo_strike)/(option_dets$hi_strike-option_dets$lo_strike)
  t_mat<-(days-option_dets$lo_mat)/(option_dets$hi_mat-option_dets$lo_mat)
  
  # bilinear interpolation formula,
  # result is vector of volatilities
  rowSums(cbind(
    vol_ll*(1-t_strike)*(1-t_mat),
    vol_hl*(t_strike)*(1-t_mat),
    vol_lh*(1-t_strike)*(t_mat),
    vol_hh*(t_strike)*(t_mat)
  ))
  
}

\end{lstlisting}

\newpage
\subsection{Unit tests}
<<,cache=FALSE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results="hide">>=
synthetic_vol<-data.table(expand.grid(
  Date=seq(Sys.Date()-365,Sys.Date(),by=1),
  Strike=seq(0,300,length.out=10),
  Days=seq(0,700,length.out=10),
  ClosePrice=100.0,
  ImpliedVol=0.1,
  market="synthetic",
  market_count=1,
  stringsAsFactors = FALSE
))[,.SD,keyby=Date]

synthetic_shedule<-make_roll_dates(
  filter_list=listed_expiries_3m,
  vsurfs=synthetic_vol
)

  
g_synthetic_90_100_ps_backtest<-make_strategy(
   strategy=list(
      leg1=list(model=EP,strike=function(close,vol,maturity){ close*0.9 },weight=(+1)),
      leg2=list(model=EP,strike=function(close,vol,maturity){ close*1.0 },weight=(-1))
    ),
    shedule=synthetic_shedule,
    volsurf=synthetic_vol
) %>% 
ggplot() +
geom_line(aes(x=date,y=pnl),size=2,alpha=0.75) +
ggtitle("90-100 PS")

g_synthetic_95_105_CS_backtest<-make_strategy(
   strategy=list(
      leg1=list(model=EC,strike=function(close,vol,maturity){ close*0.95 },weight=(+1)),
      leg2=list(model=EC,strike=function(close,vol,maturity){ close*1.05 },weight=(-1))
    ),
    shedule=synthetic_shedule,
    volsurf=synthetic_vol
) %>% 
ggplot() +
geom_line(aes(x=date,y=pnl),size=2,alpha=0.75)+
ggtitle("95-105 CS")

g_synthetic_95_C_backtest<-make_strategy(
   strategy=list(
      leg1=list(model=EC,strike=function(close,vol,maturity){ close*0.95 },weight=(+1))
    ),
    shedule=synthetic_shedule,
    volsurf=synthetic_vol
) %>% 
ggplot() +
geom_line(aes(x=date,y=pnl),size=2,alpha=0.75)+
ggtitle("Long 95 CALL")

g_synthetic_105_C_backtest<-make_strategy(
   strategy=list(
      leg2=list(model=EC,strike=function(close,vol,maturity){ close*1.05 },weight=(-1))
    ),
    shedule=synthetic_shedule,
    volsurf=synthetic_vol
) %>% 
ggplot() +
geom_line(aes(x=date,y=pnl),size=2,alpha=0.75)+
ggtitle("Short 105 CALL")

x<-make_backtest(
  shedule=synthetic_shedule,
  volsurf=synthetic_vol,
  model=EC,
  strike_fun=function(close,vol,maturity){ close*0.95 }
)

y<-compute_option_premium(
      shedule=synthetic_shedule,
      all_vol=synthetic_vol,
      strike_fun=function(close,vol,maturity){ close*0.95 },
      model=EC
)

z<-merge(
  x=synthetic_shedule[date==start,.(market, strike_close=close, strike_vol=vol, strike=close*0.95, roll)],
  y=synthetic_shedule[,.(date,market,close,roll,maturity)],
  by.x=c("market","roll"),
  by.y=c("market","roll")
)

@

\vskip 5mm

\noindent We perform a number of backtests for selected strategies on synthetic data to ensure
the backtest engine is working as expected. 

\vskip 5mm

\begin{center}
\begin{tabular}{m{10cm} m{10cm}}
\rowcolor{gray!20}
\multicolumn{2}{c}{ Synthetic market, constant price at 100, constant vol at 10\% } 
\\
\Sexpr{make_plot(plot(g_synthetic_90_100_ps_backtest),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_synthetic_95_105_CS_backtest),height="10cm",width="10cm")}
\\
\Sexpr{make_plot(plot(g_synthetic_95_C_backtest),height="10cm",width="10cm")}
&
\Sexpr{make_plot(plot(g_synthetic_105_C_backtest),height="10cm",width="10cm")}
\\
\end{tabular}
\end{center}



\end{document}


